/// <reference types="node" />
import { BitcoreError } from './errors';
import { Network, PrivateKey, HDPublicKey, PublicKey } from '.';
export declare namespace HDPrivateKey {
    type DataType = HDPrivateKeyObj<Buffer | number | string> | Buffer | string | HDPrivateKey;
    interface HDPrivateKeyObj<T> {
        network: Network | string | number;
        depth: number;
        fingerPrint?: T;
        parentFingerPrint: T;
        childIndex: T;
        chainCode: T;
        privateKey?: T;
        checksum?: T;
        xprivkey?: T;
        version?: T;
    }
}
export declare class HDPrivateKey {
    static DefaultDepth: number;
    static DefaultFingerprint: number;
    static DefaultChildIndex: number;
    static Hardened: number;
    static MaxIndex: number;
    static RootElementAlias: string[];
    static VersionSize: number;
    static DepthSize: number;
    static ParentFingerPrintSize: number;
    static ChildIndexSize: number;
    static ChainCodeSize: number;
    static PrivateKeySize: number;
    static CheckSumSize: number;
    static DataLength: number;
    static SerializedByteSize: number;
    static VersionStart: number;
    static VersionEnd: number;
    static DepthStart: number;
    static DepthEnd: number;
    static ParentFingerPrintStart: number;
    static ParentFingerPrintEnd: number;
    static ChildIndexStart: number;
    static ChildIndexEnd: number;
    static ChainCodeStart: number;
    static ChainCodeEnd: number;
    static PrivateKeyStart: number;
    static PrivateKeyEnd: number;
    static ChecksumStart: number;
    static ChecksumEnd: number;
    publicKey: PublicKey;
    _hdPublicKey: HDPublicKey;
    _buffers: HDPrivateKey.HDPrivateKeyObj<Buffer>;
    network: Network;
    depth: number;
    fingerPrint: Buffer;
    parentFingerPrint: Buffer;
    childIndex: Buffer;
    chainCode: string;
    privateKey: PrivateKey;
    checksum: Buffer;
    xprivkey: Buffer;
    version: Buffer;
    constructor(arg?: HDPrivateKey.DataType);
    static isValidPath(arg: any, hardened?: boolean): any;
    static _getDerivationIndexes: (path: any) => any;
    derive(arg: string | number, hardened?: boolean): any;
    deriveChild(arg: string | number, hardened?: boolean): any;
    deriveNonCompliantChild: (arg: any, hardened: any) => any;
    _deriveWithNumber(index: any, hardened: any, nonCompliant?: boolean): any;
    _deriveFromString(path: any, nonCompliant?: boolean): any;
    static isValidSerialized(data: HDPrivateKey.DataType, network?: Network | string): boolean;
    static getSerializedError(data: HDPrivateKey.DataType, network?: Network | string): BitcoreError;
    static _validateNetwork: (data: any, networkArg: any) => BitcoreError;
    static fromString: (arg: any) => HDPrivateKey;
    static fromObject: (arg: any) => HDPrivateKey;
    _buildFromJSON: (arg: any) => any;
    _buildFromObject: (arg: any) => any;
    _buildFromSerialized: (arg: any) => any;
    _generateRandomly(network?: string | Network): HDPrivateKey;
    static fromSeed: (hexa: any, network: any) => HDPrivateKey;
    _calcHDPublicKey: () => void;
    _buildFromBuffers: (arg: any) => any;
    get xpubkey(): Buffer;
    get hdPublicKey(): HDPublicKey;
    static _validateBufferArguments: (arg: any) => void;
    toString: () => any;
    inspect: () => string;
    toObject: () => {
        network: any;
        depth: number;
        fingerPrint: number;
        parentFingerPrint: number;
        childIndex: number;
        chainCode: string;
        privateKey: any;
        checksum: number;
        xprivkey: any;
    };
    toJSON: () => {
        network: any;
        depth: number;
        fingerPrint: number;
        parentFingerPrint: number;
        childIndex: number;
        chainCode: string;
        privateKey: any;
        checksum: number;
        xprivkey: any;
    };
    static fromBuffer: (arg: any) => HDPrivateKey;
    toBuffer: () => Buffer;
}
