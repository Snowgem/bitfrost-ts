/// <reference types="node" />
interface Recepient {
    address: string;
    satoshis: number;
}
import { BitcoreError } from '../errors';
import { Address } from '../address';
import { Input } from './input/input';
import { Output, InputTypes, TransactionSignature, MultiSigInput, MultiSigScriptHashInput, PublicKeyInput, PublicKeyHashInput } from '.';
import { Script } from '../script';
import { JSDescription } from './jsdescription';
import { SpendDescription } from './spenddescription';
import { OutputDescription } from './outputdescription';
export declare namespace Transaction {
    type TxInput = PublicKeyHashInput | PublicKeyInput | MultiSigScriptHashInput | MultiSigInput;
    interface TransactionObj {
        changeScript?: string;
        changeIndex?: number;
        inputs: Array<Transaction.TxInput | InputTypes.InputObj>;
        outputs: Array<Output | Output.OutputObj>;
        nLockTime: number;
        version: number;
        hash: string;
        fee?: number;
    }
    interface txObj {
        hash: any;
        fOverwintered: any;
        version: any;
        inputs: any;
        outputs: any;
        nLockTime: any;
        nVersionGroupId: any;
        nExpiryHeight: any;
        valueBalance: any;
        spendDescs: any;
        outputDescs: any;
        joinSplits: any;
        joinSplitPubKey: any;
        joinSplitSig: any;
        bindingSig: any;
        changeScript: any;
        changeIndex: any;
        fee: any;
    }
}
export declare class Transaction {
    static Input: typeof Input;
    static Output: typeof Output;
    static Signature: typeof TransactionSignature;
    static Sighash: {
        sighash: typeof import("./sighash").sighash;
        verify: typeof import("./sighash").verify;
        sign: typeof import("./sighash").sign;
    };
    inputs: Array<Transaction.TxInput>;
    outputs: Array<Output>;
    nLockTime: number;
    version: number;
    _inputAmount: number;
    _outputAmount: number;
    _hash: string;
    _fee: number;
    _changeScript: Script;
    _changeIndex: number;
    _feePerKb: number;
    joinSplits: Array<JSDescription>;
    spendDescs: Array<SpendDescription>;
    outputDescs: Array<OutputDescription>;
    fOverwintered: boolean;
    nVersionGroupId: number;
    nExpiryHeight: number;
    joinSplitPubKey: any;
    branchId: any;
    valueBalance: any;
    joinSplitSig: any;
    bindingSig: any;
    constructor(serialized?: Transaction | string | Transaction.TransactionObj | Buffer);
    static DUST_AMOUNT: number;
    static FEE_SECURITY_MARGIN: number;
    static MAX_MONEY: number;
    static NLOCKTIME_BLOCKHEIGHT_LIMIT: number;
    static NLOCKTIME_MAX_VALUE: number;
    static FEE_PER_KB: number;
    static CHANGE_OUTPUT_MAX_SIZE: number;
    static MAXIMUM_EXTRA_SIZE: number;
    static DEFAULT_BRANCH_ID: number;
    static shallowCopy(transaction: any): Transaction;
    get hash(): string;
    get id(): any;
    get inputAmount(): number;
    get outputAmount(): number;
    setBranchId(id: any): void;
    _getHash(): Buffer;
    serialize(unsafe: any): any;
    uncheckedSerialize(): any;
    toString: () => any;
    checkedSerialize(opts: any): any;
    invalidSatoshis(): boolean;
    getSerializationError(opts: any): any;
    _hasFeeError(opts: any, unspent: any): BitcoreError;
    _missingChange(): boolean;
    _hasDustOutputs(opts: any): BitcoreError;
    _isMissingSignatures(opts: any): BitcoreError;
    inspect(): string;
    toBuffer(): any;
    toBufferWriter(writer: any): any;
    fromBuffer(buffer: any): this;
    fromBufferReader(reader: any): this;
    toObject(): Partial<Transaction.txObj>;
    toJSON: () => Partial<Transaction.txObj>;
    fromObject(arg: any): this;
    _checkConsistency(arg: any): void;
    lockUntilDate(time: any): this;
    lockUntilBlockHeight(height: any): this;
    getLockTime(): number | Date;
    fromString(string: any): void;
    _newTransaction(): void;
    from(utxo: any, pubkeys: any, threshold: any): this;
    _fromNonP2SH(utxo: any): void;
    _fromMultisigUtxo(utxo: any, pubkeys: any, threshold: any): void;
    addInput(input: Input, outputScript?: Script | string, satoshis?: number): this;
    uncheckedAddInput(input: any): this;
    hasAllUtxoInfo(): boolean;
    fee(amount: any): this;
    feePerKb(amount: any): this;
    change(address: any): this;
    getChangeOutput(): Output;
    to(address: string | Address | Array<Recepient>, amount?: number): this;
    addData(value: any): this;
    addOutput(output: any): this;
    clearOutputs(): this;
    _addOutput(output: any): void;
    _getOutputAmount(): number;
    _getInputAmount(): number;
    _updateChangeOutput(): void;
    getFee(): number;
    _estimateFee(): number;
    _getUnspentValue(): number;
    _clearSignatures(): void;
    static _estimateFee(size: any, amountAvailable: any, feePerKb: any): number;
    _estimateSize(): number;
    _removeOutput(index: any): void;
    removeOutput(index: any): void;
    sort(): this;
    shuffleOutputs(): this;
    sortOutputs(sortingFunction: any): this;
    sortInputs(sortingFunction: any): this;
    _newOutputOrder(newOutputs: any): this;
    removeInput(txId: any, outputIndex: any): void;
    sign(privateKey: any, sigtype: any): this;
    getSignatures(privKey: any, sigtype: any): any[];
    applySignature(signature: any): this;
    isFullySigned(): boolean;
    isValidSignature(signature: any): any;
    verifySignature(sig: any, pubkey: any, nin: any, subscript: any): any;
    verify(): string | true;
    isCoinbase(): boolean;
    isRBF(): boolean;
    enableRBF(): this;
}
export {};
